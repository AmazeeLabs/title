<?php

/**
 * @file
 * Replaces entity legacy fields with regular fields.
 *
 * Provides an API and a basic UI to replace legacy pseudo-fields with regular
 * fields. The API only offers synchronization between the two data storage
 * systems and data replacement on entity load/save. Field definitions have to
 * be provided by the modules exploiting the API.
 *
 * Title implements its own entity description API to describe core legacy
 * pseudo-fields:
 * - Node: title
 * - Taxonomy Term: name, description
 * - Comment: subject
 *
 * @todo: entity label callback
 * @todo: tests
 */

module_load_include('inc', 'title', 'title.core');

/**
 * Implements hook_entity_info_alter().
 */
function title_entity_info_alter(&$info) {
  $info = array_merge_recursive($info, _title_field_replacement_core_info());

  foreach ($info as $entity_type => $entity_info) {
    if ($entity_info['fieldable'] && !empty($info[$entity_type]['field replacement'])) {
      foreach ($info[$entity_type]['field replacement'] as $legacy_field => $data) {
        // Provide defaults for the replacing field name.
        $fr_info = &$info[$entity_type]['field replacement'][$legacy_field];
        if (empty($fr_info['field']['field_name'])) {
          $fr_info['field']['field_name'] = $legacy_field . '_field';
        }
        $fr_info['instance']['field_name'] = $fr_info['field']['field_name'];

        // Provide defaults for the sync callbacks.
        $type = $fr_info['field']['type'];
        if (empty($fr_info['callbacks'])) {
          $fr_info['callbacks'] = array();
        }
        $fr_info['callbacks'] += array(
          'sync' => "title_field_{$type}_sync",
          'sync_back' => "title_field_{$type}_sync_back",
        );
      }
    }
  }
}

/**
 * Return field replacement specific information.
 */
function title_field_replacement_info($entity_type, $legacy_field = NULL) {
  $info = entity_get_info($entity_type);
  if (empty($info['field replacement'])) {
    return FALSE;
  }
  return isset($legacy_field) ? $info['field replacement'][$legacy_field] : $info['field replacement'];
}

/**
 * Implements hook_entity_presave().
 */
function title_entity_presave($entity, $type) {
  title_entity_sync($type, $entity, NULL, TRUE);
  // Store a copy of the synchronized values to check if they have been altered
  // before saving.
  $entity->field_replacement = clone($entity);
}

/**
 * Implements hook_entity_insert().
 */
function title_entity_insert($entity, $type) {
  title_entity_update($entity, $type);
}

/**
 * Implements hook_entity_update().
 *
 * Since Title is supposed to act as the first module on hook invocation, legacy
 * field values might be altered after reverse synchronization by subsequent
 * hook implementations. If this happens the field values must be synchronized
 * and the updated versions must be saved. 
 */
function title_entity_update($entity, $type) {
  $fr_info = title_field_replacement_info($type);

  if ($fr_info) {
    $update = FALSE;
    list(, , $bundle) = entity_extract_ids($type, $entity);     

    foreach ($fr_info as $legacy_field => $info) {
      if ($entity->{$legacy_field} !== $entity->field_replacement->{$legacy_field} && title_field_replacement_enabled($type, $bundle, $legacy_field)) {
        title_field_sync_back($type, $entity, $legacy_field, $info);
        $update = TRUE;
      }
    }

    if ($update) {
      // Save updated field values.
      field_attach_update($type, $entity);
    }
  }
}

/**
 * Implements hook_field_attach_load().
 *
 * Synchronization must be performed as early as possible to prevent other code
 * from accessing replaced fields before they get their actual value.
 *
 * @see title_entity_load()
 */
function title_field_attach_load($entity_type, $entities, $age, $options) {
  // @todo: Do we need to handle revisions here?
  title_entity_load($entities, $entity_type);
}

/**
 * Implements hook_entity_load().
 *
 * Since the result of field_attach_load() is cached, synchronization must be
 * performed also here to ensure that there is always the correct value in the
 * replaced fields.
 */
function title_entity_load($entities, $type) {
  foreach ($entities as &$entity) {
    title_entity_sync($type, $entity);
  }
}

/**
 * Implements hook_entitycache_load().
 *
 * Entity cache might cache the entire $entity object, in which case
 * synchronization will not be performed on entity load.
 */
function title_entitycache_load($entities, $type) {
  foreach ($entities as &$entity) {
    title_entity_sync($type, $entity);
  }
}

/**
 * Implements hook_entity_prepare_view().
 *
 * On load synchronization is performed using the current display language. A
 * different language might be specified while viewing the entity in which case
 * synchronization must be performed again.
 *
 * FIXME: $langcode is not passed along by entity_prepare_view() currently. We
 * will need to remove the default NULL value once this is fixed.
 * @see http://drupal.org/node/1089174
 */
function title_entity_prepare_view($entities, $type, $langcode = NULL) {
  foreach ($entities as &$entity) {
    title_entity_sync($type, $entity, $langcode);
  }
}

/**
 * Check whether field replacement is enabled for the given field.
 *
 * @param $entity_type
 *   The type of $entity.
 * @param $bundle
 *   The bundle the legacy field belongs to.
 * @param $legacy_field
 *   The name of the legacy field to be replaced.
 *
 * @return
 *   TRUE if field replacement is enabled for the given field, FALSE otherwise.
 */
function title_field_replacement_enabled($entity_type, $bundle, $legacy_field) {
  $info = title_field_replacement_info($entity_type, $legacy_field);
  $instance = field_info_instance($entity_type, $info['field']['field_name'], $bundle);
  return !empty($instance);
}

/**
 * Synchronize replaced fields with the regular field values.
 *
 * @param $entity_type
 *   The name of the entity type.
 * @param $entity
 *   The entity to work with.
 * @param $back
 *   Specifies the direction synchronization must be performed.
 */
function title_entity_sync($entity_type, &$entity, $langcode = NULL, $back = FALSE) {
  $sync = &drupal_static(__FUNCTION__, array());
  list($id, , $bundle) = entity_extract_ids($entity_type, $entity);
  $langcode = field_valid_language($langcode, FALSE);

  // We do not need to perform this more than once.
  if (!empty($sync[$entity_type][$id][$langcode][$back])) {
    return;
  }

  $sync[$entity_type][$id][$langcode][$back] = TRUE;
  $fr_info = title_field_replacement_info($entity_type);

  if ($fr_info) {
    foreach ($fr_info as $legacy_field => $info) {
      if (title_field_replacement_enabled($entity_type, $bundle, $legacy_field)) {
        $function = $back ? 'title_field_sync_back' : 'title_field_sync';
        $function($entity_type, $entity, $legacy_field, $info, $langcode);
      }
    }
  }
}

/**
 * Synchronize a single legacy field with its regular field value.
 *
 * @param $entity_type
 *   The name of the entity type.
 * @param $entity
 *   The entity to work with.
 * @param $legacy_field
 *   The name of the legacy field to be replaced.
 * @param $field_name
 *   The regular field to use as source value.
 * @param $display
 *   Specifies if synchronization is being performed on display or on save.
 * @param $langcode
 *   The field language to use for the source value.
 */
function title_field_sync($entity_type, $entity, $legacy_field, $info, $langcode = NULL) {
  if (isset($entity->{$legacy_field})) {
    // Find out the actual language to use (field might be untranslatable).
    $langcode = field_language($entity_type, $entity, $info['field']['field_name'], $langcode);
    $info['callbacks']['sync']($entity_type, $entity, $legacy_field, $info, $langcode);
  }
}

/**
 * Synchronize a single regular field from its legacy field value.
 *
 * @param $entity_type
 *   The name of the entity type.
 * @param $entity
 *   The entity to work with.
 * @param $legacy_field
 *   The name of the legacy field to be replaced.
 * @param $field_name
 *   The regular field to use as source value.
 * @param $display
 *   Specifies if synchronization is being performed on display or on save.
 * @param $langcode
 *   The field language to use for the source value.
 */
function title_field_sync_back($entity_type, $entity, $legacy_field, $info) {
  if (isset($entity->{$legacy_field})) {
    $langcode = title_entity_language($entity_type, $entity);
    $info['callbacks']['sync_back']($entity_type, $entity, $legacy_field, $info, $langcode);
  }
}

/**
 * Provide the original entity language.
 *
 * @param $entity_type
 * @param $entity
 *
 * @return
 *   A language code
 */
function title_entity_language($entity_type, $entity) {
  // If a language property is defined for the current entity we synchronize
  // the field value using the entity language, otherwise we fall back to
  // LANGUAGE_NONE.
  try {
    return entity_metadata_wrapper($entity_type, $entity)->language->value();
  }
  catch (EntityMetadataWrapperException $e) {
    return LANGUAGE_NONE;
  }
}

/**
 * Implements hook_field_attach_form().
 *
 * Hide legacy field widgets on the assumption that this is always called on
 * fieldable entity forms.
 */
function title_field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode) {
  list(, , $bundle) = entity_extract_ids($entity_type, $entity);
  $fr_info = title_field_replacement_info($entity_type);

  if (!empty($fr_info)) {
    foreach ($fr_info as $legacy_field => $info)  {
      if (isset($form[$legacy_field]) && title_field_replacement_enabled($entity_type, $bundle, $legacy_field)) {
        $form[$legacy_field]['#access'] = FALSE;
        $form[$legacy_field]['#field_replacement'] = TRUE;
      }
    }
  }
}

/**
 * Implements hook_field_attach_submit().
 *
 * Synchronize submitted field values into the corresponding legacy fields.
 */
function title_field_attach_submit($entity_type, $entity, $form, &$form_state) {
  $fr_info = title_field_replacement_info($entity_type);

  if (!empty($fr_info)) {
    $values = &$form_state['values'];
    $values = &drupal_array_get_nested_value($values, $form['#parents']);
    $fr_info = title_field_replacement_info($entity_type);

    foreach ($fr_info as $legacy_field => $info) {
      if (!empty($form[$legacy_field]['#field_replacement'])) {
        $field_name = $info['field']['field_name'];
        $langcode = $form[$field_name]['#language'];
  
        // Give a chance to operate on submitted values either.
        if (!empty($info['callbacks']['submit'])) {
          $info['callbacks']['submit']($values, $legacy_field, $info, $langcode);
        }
  
        title_field_sync($entity_type, $entity, $legacy_field, $info, $langcode);
      }
    }
  }
}

/**
 * Implements of hook_menu().
 */
function title_menu() {
  $items = array();

  foreach (entity_get_info() as $entity_type => $entity_info) {
    if (!empty($entity_info['field replacement'])) {
      foreach ($entity_info['bundles'] as $bundle_name => $bundle_info) {
        // Blindly taken from field_ui_menu().
        if (isset($bundle_info['admin'])) {
          $path = $bundle_info['admin']['path'];

          if (isset($bundle_info['admin']['bundle argument'])) {
            $bundle_arg = $bundle_info['admin']['bundle argument'];
          }
          else {
            $bundle_arg = $bundle_name;
          }

          $access = array_intersect_key($bundle_info['admin'], drupal_map_assoc(array('access callback', 'access arguments')));
          $access += array(
            'access callback' => 'user_access',
            'access arguments' => array('administer site configuration'),
          );

          $items["$path/fields/replace"] = array(
            'load arguments' => array(),
            'title' => 'Replace fields',
            'page callback' => 'drupal_get_form',
            'page arguments' => array('title_field_replacement_form', $entity_type, $bundle_arg),
          ) + $access;
        }
      }
    }
  }

  return $items;
}

/**
 * Implements hook_field_extra_fields_alter().
 */
function title_field_extra_fields_alter(&$info) {
  $entity_info = entity_get_info();
  foreach ($info as $entity_type => $bundles) {
    foreach ($bundles as $bundle_name => $bundle) {
      if (!empty($entity_info[$entity_type]['field replacement'])) {
        foreach ($entity_info[$entity_type]['field replacement'] as $field_name => $field_replacement_info) {
          if (title_field_replacement_enabled($entity_type, $bundle_name, $field_name)) {
            unset($info[$entity_type][$bundle_name]['form'][$field_name]);
          }
        }
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Provide settings to enable title field.
 */
function title_form_field_ui_field_overview_form_alter(&$form, &$form_state) {
  $entity_info = entity_get_info($form['#entity_type']);

  if (!empty($entity_info['field replacement'])) {
    $field_replacement_info = $entity_info['field replacement'];
    $admin_path = _field_ui_bundle_admin_path($form['#entity_type'], $form['#bundle']);
    $form['fields']['#header'][6]['colspan'] += 1;

    foreach (element_children($form['fields']) as $field_name) {
      if (isset($field_replacement_info[$field_name])) {
        $form['fields'][$field_name]['field_replacement'] = array(
          '#type' => 'link',
          '#title' => t('replace'),
          '#href' => $admin_path . '/fields/replace/' . $field_name,
          '#options' => array('attributes' => array('title' => t('Replace %field with a field instance.', array('%field' => $field_name)))),
        );
      }
      else {
        $form['fields'][$field_name]['field_replacement'] = array();
      }
    }
  }
}

/**
 * Generate a field replacement form.
 */
function title_field_replacement_form($form, $form_state, $entity_type, $bundle, $field_name) {
  $bundle_name = field_extract_bundle($entity_type, $bundle);
  $entity_info = entity_get_info($entity_type);
  $info = $entity_info['field replacement'][$field_name];
  $instance = field_info_instance($entity_type, $info['field']['field_name'], $bundle_name);

  $form['#entity_type'] = $entity_type;
  $form['#bundle'] = $bundle_name;
  $form['#field_name'] = $field_name;

  $form['enabled'] = array(
    '#type' => 'checkbox',
    '#title' => t('Replace %field with a field instance.', array('%field' => $field_name)),
    '#description' => t('If this is enabled the %field legacy field will be replaced with a regular field and will disappear from the <em>Manage fields</em> page. It will get back if the replacing field instance is deleted.', array('%field' => $field_name)),
    '#default_value' => !empty($instance),
  );

  $form['actions'] = array('#type' => 'actions');
  $form['actions']['submit'] = array('#type' => 'submit', '#value' => t('Save settings'));
  return $form;
}

/**
 * Process field replacement form subissions.
 */
function title_field_replacement_form_submit($form, &$form_state) {
  if (title_toggle_field_replacement($form['#entity_type'], $form['#bundle'], $form['#field_name'])) {
    drupal_set_message(t('%field replaced with a field instance.', array('%field' => $form['#field_name'])));
  }
  else {
    drupal_set_message(t('Field replacement removed.'));
  }
  $form_state['redirect'] = _field_ui_bundle_admin_path($form['#entity_type'], $form['#bundle']) . '/fields';
}

/**
 * Toggle field replacement for the given field.
 *
 * @param $entity_type
 *   The name of the entity type.
 * @param $bundle
 *   The bundle the legacy field belongs to.
 * @param $legacy_field
 *   The name of the legacy field to be replaced.
 */
function title_toggle_field_replacement($entity_type, $bundle, $legacy_field) {
  $entity_info = entity_get_info($entity_type);
  $info = $entity_info['field replacement'][$legacy_field];
  $field_name = $info['field']['field_name'];
  $instance = field_info_instance($entity_type, $field_name, $bundle);

  if (empty($instance)) {
    $field = field_info_field($field_name);
    if (empty($field)) {
      field_create_field($info['field']);
    }
    $info['instance']['entity_type'] = $entity_type;
    $info['instance']['bundle'] = $bundle;
    field_create_instance($info['instance']);
    return TRUE;
  }
  else {
    field_delete_instance($instance);
    return FALSE;
  }
}
